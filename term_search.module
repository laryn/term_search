<?php
/**
 * @file
 * Functions to index and search taxonomy terms.
 *
 */

/**
 * Implements hook_search_info().
 */
function term_search_search_info() {
  return array(
    'title' => 'Terms',
    'path' => 'term',
  );
}

/**
 * Implements hook_search_access().
 */
function term_search_search_access() {
  return user_access('access content');
}

/**
 * Implements hook_search_admin().
 */
function term_search_search_admin() {
  $vocabularies = taxonomy_get_vocabularies();

  foreach ($vocabularies as $vid => $vocabulary) {
    $v_options[$vid] = $vocabulary->name;
    $v_default[$vid] = $vid;
  }

  $form['term_search_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Indexed Vocabularies'),
    '#description' => '<em>' . t('Choose which vocabularies should be indexed for search.') . '</em>',
  );

  $default = variable_get('term_search_indexed_vocabularies', array());
  if (!$default) {
    $default = $v_default;
  }

  $form['term_search_fieldset']['term_search_indexed_vocabularies'] = array(
    '#type' => 'checkboxes',
    '#options' => $v_options,
    '#default_value' => $default,
  );

  return $form;
}
/**
 * Implements hook_update_index().
 */
function term_search_update_index() {
  $limit = (int) variable_get('search_cron_limit', 100);
  $vocabularies = variable_get('term_search_indexed_vocabularies', array());

  foreach ($vocabularies as $vid => $check) {
    if (!$check) {
      unset($vocabularies[$vid]);
    }
  }
  $vids = '(' . implode(',', $vocabularies) . ')';

  if (!empty($vocabularies)) {
    $query = db_select('taxonomy_term_data', 't');
	$query->leftJoin('search_dataset', 'd', 'd.sid=t.tid');
	$result = $query->condition('d.type', 'term')
	  ->condition('t.vid', $vids, NULL)
	  ->condition(db_or()->condition('d.sid', NULL)->condition('d.reindex', '<>'))
	  ->orderBy('d.reindex', 'ASC')
	  ->orderBy('t.tid', 'ASC')
	  ->range(0, $limit)
	  ->execute()
	  ->fetchAllAssoc('t.tid');
	  /*
	db_query_range("
	  SELECT t.tid 
	  FROM {taxonomy_term_data} t LEFT JOIN {search_dataset} d ON d.type = 'term' AND d.sid = t.tid
	  WHERE (d.sid IS NULL OR d.reindex <> 0) AND t.vid IN " . $vids . "
	  ORDER BY d.reindex ASC, t.tid ASC", 0, $limit);*/

    foreach ($result as $record) {
      if ($term = taxonomy_term_load($record->tid)) {
        // Render the node.
        $content = taxonomy_term_view($term);
        $term->rendered = drupal_render($content);

        $text = '<h1>' . check_plain($term->name) . '</h1>' . $term->rendered;

        // Fetch extra data normally not visible.
        $extra = module_invoke_all('term_update_index', $term);
        foreach ($extra as $t) {
          $text .= $t;
        }

        // Update index.
        search_index($term->tid, 'term', $text);
      }
    }
  }
}

/**
 * Implements hook_search_execute().
 */
function term_search_search_execute($keys = NULL, $conditions = NULL) {
  // Build matching conditions.
  $query = db_select('search_index', 'i', array('target' => 'slave'))
    ->extend('SearchQuery')
	->extend('PagerDefault');
  $query->join('taxonomy_term_data', 'te', 'te.tid = i.sid');
  $query->searchExpression($keys, 'term');

  // Insert special keywords.
  if ($query->setOption('term', 'ti.tid')) {
    $query->join('taxonomy_index', 'ti', 'n.nid = ti.nid');
  }

  // Only continue if the first pass.
  if (!$query->executeFirstPass()) {
    return array();
  }

  // Load results.
  $find = $query
    ->limit(10)
    ->execute();
  $results = array();
  foreach ($find as $item) {
    // Build the term body.
    $term = taxonomy_term_load($item->sid);

    $content = taxonomy_term_view($term, 'search_result');
    $term->body = drupal_render($content);

    $extra = module_invoke_all('term_search_result', $term);

    $results[] = array(
      'link' => url('taxonomy/term/' . $item->sid, array('absolute' => TRUE)),
      'type' => check_plain($term->vocabulary_machine_name),
      'title' => $term->name,
      'tid' => $term->tid,
      'term' => $term,
      'snippet' => search_excerpt($keys, $term->body),
    );
  }
  return $results;
}


/**
 * Implements hook_search_status().
 */
function term_search_search_status() {
  $vocabularies = variable_get('term_search_indexed_vocabularies', array());
  $remaining = $total = 0;
  foreach ($vocabularies as $vid => $check) {
    if (!$check) {
      unset($vocabularies[$vid]);
    }
  }
  $vids = '(' . implode(',', $vocabularies) . ')';
  if (!empty($vocabularies)) {
    $total = db_select('taxonomy_term_data', 't')
	  ->condition('t.vid', $vids, 'IN')
	  ->countQuery()
	  ->execute()
	  ->fetchField();
	$query = db_select('taxonomy_term_data', 't');
	$query->leftJoin('search_dataset', 'd', 'd.sid=t.tid');
    $remaining = $query->condition('d.type', 'term')
	  ->condition('t.vid', $vids, 'IN')
	  ->condition(db_or()->condition('d.sid', NULL)->condition('d.reindex', '0', '<>'))
	  ->countQuery()
	  ->execute()
	  ->fetchField();
	  /*
	db_query("
      SELECT COUNT(*) 
      FROM {taxonomy_term_data} t LEFT JOIN {search_dataset} d 
      ON d.type = 'term' AND d.sid = t.tid 
      WHERE (d.sid IS NULL OR d.reindex <> 0) AND t.vid IN " . $vids)->fetchField();
	  */
  }
  
  return array('remaining' => $remaining, 'total' => $total);
}


/**
 * Implements hook_taxonomy_term_update().
 * Sets the term to be reindexed when the term is updated.
 */
function term_search_taxonomy_term_update($term) {
  db_update('search_dataset')
    ->condition('sid', $term->tid)
    ->condition('type', 'term')
    ->fields(array('reindex' => 1))
    ->execute();
}
